\section{GUI}
\label{sec:Gui}
\subsection{Bakgrunn}
GUI, graphical user interface, er et grensesnitt som lar brukerne samhandle med et dataprogram grafisk, vanligvis ved hjelp av tastatur og datamus. I motsetning til typiske shellapplikasjoner hvor man navigerer ved hjelp av kommandoer, består et grafiske grensesnittet ofte av grafiske ikoner og lydindikatorer.\cite{wiki:GUI} Grunnet den bratte læringskurven på en kommandobasert datamaskin med shellapplikasjoner ble grafisk brukergrensesnitt med mulighet for å bruke mus til å klikke på knapper, tekstfelt og informasjonsfelt raskt populært. Hos de to mest populære operativsystemene på markedet i dag, Windows og MacOS, er det GUI-et står i sentrum, mens det i UNIX er det mer en blanding av et kommandobasert system og grafisk brukergrensesnitt.

Vi ønsket at det skulle være lettere å benytte seg våre implementasjoner nevnt fra kapittel \ref{sec:Glatting} - \ref{sec:Anonymisering}, og bestemte oss for å lage vårt eget program med et grafisk brukergrensesnitt. Her skal det være mulighet for å utføre alle de implementerte operasjonene interaktiv på ulike utvalgte bilder. Vi endte opp med å bruke det foreslåtte rammeverket \texttt{PyQt5}\footnote{\url{https://pypi.org/project/PyQt5/}}, som gjør det enkelt å bruke implementasjonene skrevet vi allerede hadde skrevet med Python i GUI-applikasjonen. Ved å skrive programmet i PyQt5 kan man kjøre programmet på både Windows, MacOS og Linux, noe som gjør at vi forminsker arbeidsmengden betraktelig.

\subsection{Implementasjon}
Programmet kjøres fra \texttt{Main.py} hvor main ligger. Vi har valgt en vindusbasert applikasjon hvor man fra hjemskjermen kan velge hvilken implementasjon man har lyst til å benytte seg av. Vi har funnet det hensiktsmessig å dele applikasjonen opp i ulike moduler, hvor det er en modul for hjemskjermen og en modul for hver av implementasjonene. Hver modul har sin egen .py-fil i mappa \texttt{src/GUI} hvor all kode er lagret. Dette har vi gjort for god organisering ved å skille de ulike modulene i applikasjonen fra hverandre. Det er også mer oversiktelig når vi importerer de ulike bibliotekene vi har bruk for i den aktuelle modulen. 

På grunn av at vi har valgt en vindusbasert applikasjon har vi derfor laget et design for hver modul. Designet til hver modul lagres som en .ui-fil som importeres når en modul initialiseres. Designet er gjort i \texttt{Qt5 Designer}\footnote{\url{https://pypi.org/project/PyQt5Designer/}}, som gjør det enkelt å lage et oversiktelig UI med tekstfelter, knapper og bilder. Alle .ui-filene er lagret i mappa \texttt{src/GUI/UI}. Hver gang Main.py lastes tilpasses applikasjonen slik at den oppfører seg likt på skjermer med ulik pikseltetthet.

\begin{lstlisting}[language=Python]
QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling,True)
QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps,True)
\end{lstlisting}

Når en modul initialiseres må vinduets dimensjoner justeres. Dette må gjøres fordi designet er laget med Qt5 Designer, og oppfører seg derfor annerledes på skjermer med ulike dimensjoner. Disse justeringene gjøres ved hjelp av funksjonen adjustScreen(). Her får man dimensjonen ved å hente skjermens høyde og bredde, og bruker denne til å justere vinduet. Hvert vindu er forskjellig fra hverandre, og derfor har hver modul sin egen adjustScreen() funksjon.

\begin{lstlisting}[language=Python]
def adjustScreen(self):
    screenWidth = app.primaryScreen().size().width()
    screenHeight = app.primaryScreen().size().height()
    if screenWidth/screenHeigh == 1.5:
        width = int(screenWidth / 1.8)
        height = int(screenHeight / 2)
    else:
        width = int(screenWidth / 2.22222)
        height = int(screenHeight / 1.95298)
    self.setGeometry(500, 80, width, height)
\end{lstlisting}

Hjemskjermen består av et antall knapper med tilhørende tekst som forklarer hva den aktuelle implementasjonen gjør. Når man klikker på en knapp opprettes en dialog til denne modulen. Hvis det lykkes med å opprette en dialog vil et nytt vindu åpnes hvor den aktuelle modulens design og funksjonaliteter vises. 

Hovedelementet i hver modul er bildet som man ser i (figur \ref{fig:guiexample}) Vi har valgt å bruke MatPlotLib til å vise bilder. Dette gjør at vi kan bruke \texttt{plt.imshow()}\footnote{\url{https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.imshow.html}} som vi har brukt i hver enkelt implementasjon i Jupyter Notebook-filene. I vår applikasjon er dette en bedre metode å vise bilder på sammenliknet med alternativet hvor vi da ville brukt QLabel og \texttt{setPixMap}\footnote{\url{https://doc.qt.io/archives/qt-4.8/qlabel.html#pixmap-prop}}. Selve bildet er et imagewidget av typen FigureCanvas, og vi har derfor opprettet en egen klasse \texttt {imagewidget} i filen \texttt{src/imagewidget}. Ved oppstart av hver modul initialiseres imagewidget hvor \texttt{self.img} opprettes og initialiseres. Hver gang et nytt bilde skal vises kalles \texttt{showImage(self, image, colour=True)}. Her blir det lagt til subplot, aksene fjernes og bildet justeres slik at det fyller mest mulig av bilderammen. Avhengig av om colour er True eller False, vises enten et fargebilde eller et gråtonebilde ved bruk av imshow(). Det er i hver modul lagret \texttt{self.path} som hele tiden er oppdatert med filstien til bilde som er valgt. Denne benyttes når brukeren vil se annet bilde eller ta bort effekten gjort på bildet og vise originalbildet. Hver modul har også en lokal variabel \texttt{self.image} hvor det bildet som vises i applikasjonen ligger lagret som en numpy array. Denne brukes når brukeren vil lagret bildet, hvor den sendes til \texttt{FunctionGUI/saveImage}. Her åpnes en \texttt{QFileDialog}\footnote{\url{https://doc.qt.io/qt-5/qfiledialog.html}}, som returnerer ønsket navn på filen og filsti til ønsket mappe.

\begin{figure}
\begin{center}
    \includegraphics[width=0.5\columnwidth]{bilder/Gui/guiexample.jpg}
     \caption{Grafisk brukergrensesnitt - Glatting \label{fig:guiexample}}
\end{center}
\end{figure}

I hver modul importeres klassen \texttt{showCode(QMainWindow)}, som viser koden i et nytt vindu for implementasjonen. Koden som vises ligger lagret i en .txt-fil i \texttt{src/codes}, som vises ved å bruke funksjonen \texttt{FunctionGUI/ShowCode}. Her opprettes det et nytt \texttt{QMainWindow}, hvor koden vises i et rullbar tekstfelt. 

\subsubsection{Glatting}
Et bilde kan glattes ved å bruke en eksplisitt løsning av diffusjonslikningen. Dette gjøres av funksjonen \texttt{blurImage(self, colour)}. Denne henter først et fargebilde hvis colour er True eller gråtonebilde hvis colour er False. Videre lages en kopi av originalbilde som det legges litt støy på, før dette glattes ved å bruke funksjonen \texttt{eksplisittGlatting()} fra \texttt{Eksplisitt.py}. Tilslutt vises bildet ved å bruke modulens showImage-funksjon.

Bildet kan også glattes ved å bruke en implisitt løsning av diffusjonslikningen. Dette gjøres at funksjonen \texttt{blurImageImplsitt(self, colour=True)}. Hvis colour er True leses det inn et fargebildet, og hvis colour er False leses det inn et gråtonebilde ved bruk av \texttt{grayscale()} fra \texttt{Grayscale.py}. Disse bildene lagres som en numpyarray \texttt{u} som videre omformes til å inneholde verdier mellom 0 og 1, hvor verdier over 1 og under 0 klippes til lovlige verdier. Deretter glattes bildet \texttt{u} ved å bruke funksjonen \texttt{implisitt()} fra \texttt{implisitt.py}. Tilslutt vises bildet ved å bruke showImage-funksjonen i modulen.

\subsubsection{Inpainting}
I Inpainting sitt GUI er det mulig å få vist bildet med manglende informasjon før det fylles inn. Dette gjøres ved å bruke funksjonen \texttt{showMask(self)}, som sender med \texttt{self.path} og tallet \texttt{2} til funksjonen \texttt{Inpaint()} fra \texttt{Inpainting.py}. Denne funksjonen returnerer bildet med masken, som vises ved å bruke \texttt{showImage()} i modulen. Informasjonen i bildet fylles inn i funksjonen \texttt{inpaint(self)}, som sender med \texttt{self.path} og tallet \texttt{3} til \texttt{Inpaint()} fra \texttt{Inpainting.py}. Her returneres et bilde hvor informasjonen er fylt inn, som vises av \texttt{showImage()}. 

\subsubsection{Kontrastforsterkning}
Når knappen \texttt{contrastColour} trigges starter funksjonen \texttt{contrastImage(self)}. Denne funksjonen kaller på \texttt{contrastEnhance()} fra \texttt{contrastEnhancement.py} og sender med \texttt{self.path} og den aktuelle verdien på \texttt{QDoubleSpinBox}\footnote{\url{https://doc.qt.io/qtforpython/PySide2/QtWidgets/QDoubleSpinBox.html}} som brukeren har satt en verdi på. \texttt{contrastEnhancement()} returnerer et kontrastforsterket bilde som vises i GUI av \texttt{showContrastImage(self, im, colour=True)}. Hvis brukeren trigger knappen \texttt{contrastOrigGray} startes funksjonen \texttt{contrastGrayImage(self)}. Her sendes \texttt{self.path} og verdien på \texttt{QDoubleSpinBox} med til \texttt{contrastEnhanceBW()} i \texttt{contrastEnhancement.py}, og returnerer et kontrastforsterket gråtonebilde. Dette vises av \texttt{showContrastImage()}.

\subsubsection{Demosaicing}
Det er mulig å bruke to forskjellige metoder å gjøre demosaicing på et bilde i denne modulen. Hvis man vil bruke metoden som innebærer at man manuelt fyller inn informasjonen fra gråtonemosaikken inn i hver fargekanal, opprette en maske for fargekanalene og inpainte den manglende informasjonen med bruk av diffusjonslikningen, kan gjøres dette med \texttt{demosaicImage()}. Denne bruker \texttt{mosaicToRGB()} til å utføre demosaicingen, som vises på skjermen ved å bruke \texttt{showImage()}. Hvis man har lyst til å se gråtonemosaikken før informasjonen inpaintes gjøres dette av \texttt{mosaic()}, hvor gråtonemosaikken returneres av \texttt{getMosaic()} og vises av \texttt{showImage()}. Ønsker man heller bruke biblioteket \texttt{Colour-demosaicing}\footnote{\url{https://pypi.org/project/colour-demosaicing/}} til å gjøre demosaicing av bildet gjøres dette ved å bruke \texttt{demosaicImagePackage}. Her brukes \texttt{Colour} først til å lage en gråtonemosaikk, før denne gråtonemosaikken demosaices ved å bruke \texttt{Colour-demosaicing}. Hvis man har lyst til å se gråtonemosaikken som lages med dette biblioteket gjøres dette med \texttt{mosaicPackage()}. Gråtonemosaikken og bildet som det er gjort demosaicing på vises begge med \texttt{showImage()}. 

\subsubsection{Sømløs kloning}
For å sømløst klone en av de tre forhåndsvalgte sammensetningene av bilder brukes \texttt{seamlessImage(self, number, img1, img2)}. \texttt{Number} er verdien på hvilken av kombinasjonene som klones. Deretter sjekkes verdi på den aktuelle av de tre lokale boolvariablene. Disse boolvariable fungerer som status på om noen av de tre forhåndsvalgte kombinasjonene av bilder allerede er regnet ut. Disse settes til False ved oppstart av modulen, og oppdateres til True hvis den aktuelle kombinasjonen av bilder er blitt klonet. Dette er gjort fordi det å sømløst klone et bilde er en regnetung oppgave og tar lang tid, og ved å lagre bildet kan brukeren raskt kan sammenlikne bildet før og etter kloning. Hvis den aktuelle boolverdien er False klones bildet av \texttt{seamless(img1, img2)} og lagres i \texttt{self.seamlessImageOne}, før den aktuelle \texttt{self.imgXReady} settes til True. Er boolverdien ikke False er dette allerede gjort og \texttt{showImage()} kan vise det ferdig klonede bildet. 

\subsubsection{Konvertering av fargetone til gråtone}
Når den enkle metoden for å konvertere et bilde til gråtone skal benyttes brukes \texttt{convertGrayEasy()} til å kalle på funksjonen \texttt{grayscale}. Her returneres gråtonebildet som sendes til \texttt{showImage()} som viser bildet på skjermen. Velges den mer sofistikerte metoden for å konverte et gråtonebilde brukes \texttt{convertGrayAdvanced()}. Her returneres det et gråtonebilde fra \texttt{rgb2gray()} som vises på skjermen av \texttt{showImage()}.

\subsection{Anonymisering}


\subsection{Brukermanual}


\subsubsection{Glatting}


\subsubsection{Inpainting}


\subsubsection{Kontrastforsterkning}


\subsubsection{Demosaicing}


\subsubsection{Sømløs kloning}


\subsubsection{Konvertering av fargetone til gråtone}


Ta med til konklusjon: 
- gjort på nytt, droppet bruk av QtDesigner og heller skrevet alt i kode. Litt mer kontroll og lettere å justere visning av vinduer. Kunne da også enkelt implementert støtte for å kunne justere vinduer ved å dra i kantene
- droppet bruk av .ui-filer som hadde gjort det mye enklere å organisere prosjektet på en bedre måte
- En del cowboyløsninger når man bygger på og bygger på, spesielt lagring av bilder ble ganske rotete og unødvendig komplisert til slutt
- Mange steder som man kanskje burde laget GUI annerledes
- Lagring av bilder har hatt verdier mellom 0 og 1 har lavere kvalitet

Hva som trengs:
- Colour
- Colour-demosaicing
- PIL
- cv2
